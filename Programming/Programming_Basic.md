# Programming Basic
1. 절차지향 & 객체지향 프로그래밍
2. 컴파일러 & 인터프린터
3. 
</br>

## 절차지향 & 객체지향 프로그래밍
* 프로그래밍 방법론(패러다임)
* Example : 사람이 음료 자판기에서 음료를 뽑는다.
    ![POP_OOP](img/POP_OOP.png)
* ref
    * https://www.slideshare.net/QooJuice/vs-60147566
    * http://www.incodom.kr/%EC%A0%88%EC%B0%A8_%EC%A7%80%ED%96%A5

### 절차지향 (Procedural Oriented)
* __절차를 중심으로 코드를 작성한다.__
* 데이터(구조체)와 함수(기능)가 분리되어 있다.
* 함수들이 데이터에 "종속성"을 나타내지 못하기 때문에 다른 영역에서 해당 함수를 호출하는 실수를 범할 수 있다.
</br>

### 객체지향 (Object Oriented)
* __객체를 중심으로 함수를 작성한다.__
* 데이터(클래스)와 함수가 분리되어 있지 않다.
* 함수가 클래스에 "종속성"을 띤다.
</br>

### 결론 (Conclusion)
* 정리를 하며 든 나의 생각은 규모가 커지고, 유지/보수가 커짐에 따라 절차지향 -> 객체지향으로 바뀌었다고 생각한다.
> 그러면 무조건 객체지향이 좋나? => 아니다. 소규모 작업인 경우는 절차지향이 더 좋을 수 있다고 생각한다.

> 하지만 설계와 개발 시간이 충분하고, 유지/보수 등을 생각하면 객체지향이 좋다고 생각한다.
</br>
</br>



## 컴파일러 & 인터프리터
* 각 방식의 Build Process는 다음과 같다.

### 컴파일러 (Compiler)
![Compiler](img/Compiler.png)
* 기본 과정
    1) 헤더 파일(.h) 작성, 함수 및 클래스 선언
    2) 소스 파일(.c) 작성, 헤더 파일에서 선언한 함수의 기능 코드 작성
    3) 컴파일러를 통해 Object 파일 생성
    4) 링커를 통해 Object 파일들을 링크하여, 실행 파일을 생성
    5) 해당 장치에서 실행 파일을 실행
* __전처리기(Preprocessor)__ : 각 소스 파일에서 지시자를 찾는다. 지시자는 # 으로 시작해서 줄 바꿈으로 끝나는 코드이다. 전처리기는 컴파일러가 실행되기 직전에 단순히 텍스트를 조작하는 치환 역할을 하기도 하고, 디버깅에도 도움을 주며 헤더 파일의 중복 포함도 방지해주는 기능을 가진다.
* __컴파일(Compile)__ : 소스 파일을 바이너리 파일(기계어)로 번역하는 작업. Object 파일을 생성.
* __링크(Link)__ : 분리된 파일들을 연결시켜 실행 파일을 생성(코드를 하나의 파일에서만 작업하지 않으므로 연결할 필요가 있다.)
* __빌드(Build)__ : 컴파일과 링크 과정을 합쳐서 빌드라고 함
* __라이브러리__ : 컴파일된 함수(기능)를 구현하는 코드가 저장되어 있는 파일들 모음
* __헤더 파일__ : 함수(기능)를 호출하기 위한 방법(인터페이스) 정보가 저장되어 있는 파일
</br>

### 인터프리터 (Interpreter)
![Interpreter](img/Interpreter.png)
* 기본 과정
    1) 소스 파일(.java/.py)을 컴파일러를 통해 바이트 코드 파일(.class/.pyc) 생성
    2) 바이트 코드 파일를 인터프리터가 해석하고 실행
* __바이트 코드 파일__ : 특정 VM이 읽을 수 있는(해석) 코드 파일 
* __인터프리터__ : 특정 VM에서 바이트 코드 파일을 해석하고 실행시키는 장치
</br>

### JAVA 컴파일 과정
![JVM](img/JVM.png)
* 기본 과정
    1) a
    2) b
    3) c
* ____ : 
* ____ : 
* ____ : 
* ____ : 
* ____ : 
* ____ : 
</br>
</br>






